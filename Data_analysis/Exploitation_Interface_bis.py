import scipy as sp
from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import copy

## Constantes

#en USI
mu_air=1.225 
cste_moteur=980/(60) #en tour par seconde par volt pour avoir v=pas*omega _ Kv
eForce_Theoriqueicacite=0.78
masse=1.6
g=9.81
tension=13.90

## Extraction des données

def lecture_data_experience(file='data_experience.csv'):
    f = open(file,'r')
    data = []
    flag=0
    for line in f:
        code_helice_i , commande_i , tension_i , intensite_i , vitesse_rotation_i , force_i = line.split(';')
        if flag==0:
            data.append(['code helice' , 'commande (%)' , 'tension (V)' , 'intensite (A)' , 'vitesse rotation (tour/min)' , 'force (gram)'])
            flag = 1
        else:
            data.append([int(code_helice_i) , int(commande_i) , float(tension_i) , float(intensite_i) , float(vitesse_rotation_i) , float(force_i)])
    f.close()
    return data

            
def lecture_data_helice(file='data_helice.csv'):
    f = open(file,'r')
    data = []
    flag=0
    for line in f:
        code_helice,pitch,diametre,description = line.split(';')
        if flag==0:
            data.append(['code helice' , 'pitch (inch)' , 'diametre (inch)' , 'description' ])
            flag = 1
        else:
            data.append([int(code_helice) , float(pitch) , float(diametre) , description])
    f.close()
    return data
    
data_helice=lecture_data_helice()
data_experience=lecture_data_experience()



    




## Force théorique

def force_stationnaire(masse):
    return masse*g/4



def Force_Theorique(pas,rayon,vitesse_rotation): #Calcul force en Newton
    return mu_air*np.pi*((rayon*pas*vitesse_rotation)**2)
    
def Intensite_Theorique(pas, rayon, vitesse_rotation, Kc=1/cste_moteur):
    return mu_air*np.pi*rayon*rayon*pas*pas*pas*vitesse_rotation*vitesse_rotation/Kc
    
    

## Conversion SI

def conversion():
    
    pas=[]
    rayon=[]
    flag=0
    for i in range(len(data_helice)):
        if flag==0:
            flag=1
        else:
            pas.append(float(0.0254*data_helice[i][1]))
            rayon.append(float(0.0254*data_helice[i][2])/2)
    return pas,rayon

def recup_force():
    force=[]
    flag=0
    for i in range(len(data_experience)):
        if flag==0:
            flag==1
        if data_experience[i][1]==100:
            force.append(g*float(data_experience[i][5])*0.001)
    return force
    
def recup_vitesse_rotation():
    omega=[]
    flag=0
    for i in range(len(data_experience)):
        if flag==0:
            flag=1
        if data_experience[i][1]==100:
            
            omega.append(float(data_experience[i][4]/60))
    return omega

pas=conversion()[0]
rayon=conversion()[1]
force=recup_force()[:14]+[0]+recup_force()[14:]

force_necessaire=force_stationnaire(masse)
vitesse_rotation=recup_vitesse_rotation()[:14]+[0]+recup_vitesse_rotation()[14:]

## Tracé de la force en fonction des hélices (à 100% des moteurs)


def trace_forces_helices():
    force_exp=[]
    force_theorique=[]
    numero_helice=[]
    force_minimum=[]
    for i in range(18):
        if i!=14:
            force_exp.append(force[i])
            numero_helice.append(i+1)
            force_minimum.append(force_necessaire)
            force_theorique.append(Force_Theorique(pas[i],rayon[i],vitesse_rotation[i]))
    plt.plot(numero_helice,force_exp,'ro', label='force mesurée sur banc d essai')
    plt.plot(numero_helice,force_minimum, color='b', label='force minimum pour faire voler le drone')
    plt.plot(numero_helice,force_theorique,'yo',label='force théorique developpée par l hélice')
    plt.title('Force en fonction de l hélice utilisée')
    plt.legend()
    plt.xlabel('numero hélice')
    plt.ylabel('force (en Newton)')
    plt.xlim(0,19)
    
    
    plt.show()
            
        
## Tracé de la force en fonction des rpm (comparaison force theorique force expérimentale)



def applique_formule_force(num_experience, beta=0.64):
    'prends en argument le numero n associe a une experience : nieme ligne de data_experience'
    'retourne la force theorique calculé et la force mesurée experimentalement'
    code_helice,commande,tension,intensite,vitesse_rotation,force_experimentale = data_experience[num_experience]
    code_helice_verif,pitch,diametre,description = data_helice[code_helice]
    #conversion au vol
    force_theorique = (1000*Force_Theorique((diametre*0.0254)/2,pitch*0.0254,vitesse_rotation/60)/g)*beta
    
    if code_helice != code_helice_verif:
        return False
    return force_theorique,force_experimentale


def tracage_verification_thurst():
    colors = ['darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','FAIL','darkslateblue','darkslategray','darkturquoise','darkviolet']
    darkblue_line = mlines.Line2D([],[], color='darkblue', label='HQprop 0943 Multirotor')
    darkcyan_line = mlines.Line2D([],[], color='darkcyan', label='HQprop 0945 Multirotor')
    darkgoldenrod_line = mlines.Line2D([],[], color='darkgoldenrod', label='HQprop 0947 Slow-Flyer')
    darkgray_line = mlines.Line2D([],[], color='darkgray', label='HQprop 0950 Thin Electric')
    darkgreen_line = mlines.Line2D([],[], color='darkgreen', label='HQprop 1045 Multirotor')
    darkkhaki_line = mlines.Line2D([],[], color='darkkhaki', label='HQprop 1045 Slow-Flyer')
    darkmagenta_line = mlines.Line2D([],[], color='darkmagenta', label='HQprop 1047 Slow-Flyer')
    darkolivegreen_line = mlines.Line2D([],[], color='darkolivegreen', label='HQprop 1050 Thin Electric')
    darkorange_line = mlines.Line2D([],[], color='darkorange', label='APC 0945 Multirotor')
    darkorchid_line = mlines.Line2D([],[], color='darkorchid', label='APC 0947 Slow-Flyer')
    darkred_line = mlines.Line2D([],[], color='darkred', label='APC 1047 Slow-Flyer')
    darksalmon_line = mlines.Line2D([],[], color='darksalmon', label='APC 1045 Multirotor')
    darkseagreen_line = mlines.Line2D([],[], color='darkseagreen', label='APC 1047 Multirotor')
    darkslateblue_line = mlines.Line2D([],[], color='darkslateblue', label='Gemfan 1038')
    darkslategray_line = mlines.Line2D([],[], color='darkslategray', label='Gemfan 1045')
    darkturquoise_line = mlines.Line2D([],[], color='darkturquoise', label='Graupner 0940')
    darkviolet_line = mlines.Line2D([],[], color='darkviolet', label='Graupner 1040')
    blue_patch = mpatches.Patch(color='blue', label='Valeur théorique')
    red_patch = mpatches.Patch(color='red', label='Valeur expérimentale')
    
    for num_exp in range(1,69):
        code,commande,tension,intensite,RPM,thurst=data_experience[num_exp]
        codebis,pitch,diametre,desc=data_helice[code]

        
        if code!=codebis:
            return 'FAIL'
        
        thurst_theo,thurst_exp= applique_formule_force(num_exp)
        plt.plot(RPM,thurst_theo,'ro',markersize=7)
        plt.plot(RPM,thurst_exp,'bo',markersize=7)
        plt.plot([RPM,RPM],[thurst_theo,thurst_exp],label='{}'.format(code),color='{}'.format(colors[code-1]),linewidth=1.5)
    

    
    plt.legend([blue_patch,red_patch,darkblue_line,darkcyan_line,darkgoldenrod_line,darkgray_line,darkgreen_line,darkkhaki_line,darkmagenta_line,darkolivegreen_line,darkorange_line,darkorchid_line,darkred_line,darksalmon_line,darkseagreen_line,darkslateblue_line,darkslategray_line,darkturquoise_line,darkviolet_line],bbox_to_anchor=(1,0.5),loc='center left',fontsize=15)
    
    plt.grid()
    plt.suptitle('Erreur de calcul de la force de poussée',fontsize=25)
    plt.xlabel(r'Vitesse de rotation $ (tour/minute) $',fontsize=20)
    plt.ylabel(r'Force de poussée $ (gramme) $',fontsize=20)
    plt.show()
    #plt.savefig('test.png')
    return 'Done'
        

        
## Trace de l'intensite en fonction des rpm


#renvoie le couple intensite theorique intensite experimentale

def applique_formule_intensite(num_experience, alpha=1/2):
    'prends en argument le numero n associe a une experience : nieme ligne de data_experience'
    'retourne la force theorique calculé et la force mesurée experimentalement'
    code_helice,commande,tension,intensite,vitesse_rotation,force_experimentale = data_experience[num_experience]
    code_helice_verif,pitch,diametre,description = data_helice[code_helice]
    #conversion au vol
    intensite_theorique = (Intensite_Theorique(float(pitch)*0.0254, (diametre*0.0254)/2, vitesse_rotation/60)) * alpha
    
    if code_helice != code_helice_verif:
        return False
    return intensite_theorique,intensite

def tracage_verification_intensity():
    colors = ['darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','FAIL','darkslateblue','darkslategray','darkturquoise','darkviolet']
    darkblue_line = mlines.Line2D([],[], color='darkblue', label='HQprop 0943 Multirotor')
    darkcyan_line = mlines.Line2D([],[], color='darkcyan', label='HQprop 0945 Multirotor')
    darkgoldenrod_line = mlines.Line2D([],[], color='darkgoldenrod', label='HQprop 0947 Slow-Flyer')
    darkgray_line = mlines.Line2D([],[], color='darkgray', label='HQprop 0950 Thin Electric')
    darkgreen_line = mlines.Line2D([],[], color='darkgreen', label='HQprop 1045 Multirotor')
    darkkhaki_line = mlines.Line2D([],[], color='darkkhaki', label='HQprop 1045 Slow-Flyer')
    darkmagenta_line = mlines.Line2D([],[], color='darkmagenta', label='HQprop 1047 Slow-Flyer')
    darkolivegreen_line = mlines.Line2D([],[], color='darkolivegreen', label='HQprop 1050 Thin Electric')
    darkorange_line = mlines.Line2D([],[], color='darkorange', label='APC 0945 Multirotor')
    darkorchid_line = mlines.Line2D([],[], color='darkorchid', label='APC 0947 Slow-Flyer')
    darkred_line = mlines.Line2D([],[], color='darkred', label='APC 1047 Slow-Flyer')
    darksalmon_line = mlines.Line2D([],[], color='darksalmon', label='APC 1045 Multirotor')
    darkseagreen_line = mlines.Line2D([],[], color='darkseagreen', label='APC 1047 Multirotor')
    darkslateblue_line = mlines.Line2D([],[], color='darkslateblue', label='Gemfan 1038')
    darkslategray_line = mlines.Line2D([],[], color='darkslategray', label='Gemfan 1045')
    darkturquoise_line = mlines.Line2D([],[], color='darkturquoise', label='Graupner 0940')
    darkviolet_line = mlines.Line2D([],[], color='darkviolet', label='Graupner 1040')
    blue_patch = mpatches.Patch(color='blue', label='Valeur théorique')
    red_patch = mpatches.Patch(color='red', label='Valeur expérimentale')
    
    for num_exp in range(1,69):
        code,commande,tension,intensite,RPM,thurst=data_experience[num_exp]
        codebis,pitch,diametre,desc=data_helice[code]

        
        if code!=codebis:
            return 'FAIL'
        
        inten_theo,inten_exp = applique_formule_intensite(num_exp)
        plt.plot(RPM,inten_theo,'ro',markersize=7)
        plt.plot(RPM,inten_exp,'bo',markersize=7)
        plt.plot([RPM,RPM],[inten_theo,inten_exp],label='{}'.format(code),color='{}'.format(colors[code-1]),linewidth=0.5)
    
    # plt.legend(handles=[blue_patch,red_patch,darkblue_line,darkcyan_line,darkgoldenrod_line,darkgray_line,darkgreen_line,darkkhaki_line,darkmagenta_line,darkolivegreen_line,darkorange_line,darkorchid_line,darkred_line,darksalmon_line,darkseagreen_line,darkslateblue_line,darkslategray_line,darkturquoise_line,darkviolet_line],bbox_to_anchor=(1,0.5),loc='center left',fontsize=15)
    plt.show()
    plt.grid()
    plt.suptitle("Erreur de calcul de l'intensité",fontsize=25)
    plt.xlabel(r'Vitesse de rotation $ (tour/minute) $',fontsize=20)
    plt.ylabel(r'Intensité $ (ampère) $',fontsize=20)
    #plt.savefig('test.png')
    return 'Done'    
    

## Correction Force
def ecriture_force_incertitude_csv(data,k1=0.3327,k2=1.5):
    'prend le tableau data_experience et cree un .csv en ajoutant la force calcule'
    data_final = copy.deepcopy(data)
    diff_tot = 0
    erreur_tot = 0
    
    for ligne in range(len(data_final)):
        if ligne != 0:
            forces = applique_formule_force(ligne)
            diff = forces[0]-forces[1]

            data_final[ligne].append(int(forces[0]))
            data_final[ligne].append(int(diff))
    
    data_final[0].append('force theorique')
    data_final[0].append('Theorique-Mesure (moyenne={})'.format(str(diff_tot/(len(data_final)-1))))
    data_final[0].append('k1={} et k2={}'.format(str(k1),str(k2)))
    
    ecriture_tableau_csv(data_final,'experience_analyse_force.csv')
    
    return 'Done'

def ecriture_tableau_csv(liste,nom_fichier):
    fichier = open('{}'.format(nom_fichier), "a")
    for ligne in range(len(liste)):
        for elements in liste[ligne]:
            fichier.write('{};'.format(str(elements)))
        fichier.write('\n')
    fichier.close()
    return None


def rapport_exp_theo_force(num_exp):
    code_helice,commande,tension,intensite,vitesse_rotation,force_experimentale = data_experience[num_exp]
    code_helice_verif,pitch,diametre,description = data_helice[code_helice]
    #conversion au vol
    force_theorique = (1000*Force_Theorique((diametre*0.0254)/2,pitch*0.0254,vitesse_rotation/60)/g)
    
    if code_helice != code_helice_verif:
        return False
    return vitesse_rotation, force_experimentale-force_theorique

def tracage_rapport_exp_theo_force():
    x=[]
    y=[]
    for num in range (1,69):
        w,rapport=rapport_exp_theo_force(num)
        x.append(w)
        y.append(rapport)
    
    slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)
    
    valeur_w=np.linspace(0,10000,5000)
    #plt.plot(valeur_w,-0.0000000012*(valeur_w)**3) #0.000009
    plt.plot(valeur_w,-0.000008*(valeur_w)**2)
    plt.plot(valeur_w,-0.000008*(valeur_w)**2-183)
    plt.plot(valeur_w,-0.000008*(valeur_w)**2+183)
    plt.plot(x,y,"bo")
    plt.show()
    return slope,intercept #slope * w + intercept

#valeurs de notre fonction correctrice 
   
# coeffdirecteur=tracage_rapport_exp_theo_force()[0]
# valeurorigine=tracage_rapport_exp_theo_force()[1]

def Force_corrigee(pas,rayon,vitesse_rotation):
    #vitesse en tr/s et force en Newton
    return Force_Theorique(pas,rayon,vitesse_rotation) + 0.000008*(vitesse_rotation/60)**2
    
    
    
    
def applique_formule_force_corrigee(num_experience):                        ###########FONCTION FINALE
    'prends en argument le numero n associe a une experience : nieme ligne de data_experience'
    'retourne la force theorique calculé et la force mesurée experimentalement'
    code_helice,commande,tension,intensite,vitesse_rotation,force_experimentale = data_experience[num_experience]
    code_helice_verif,pitch,diametre,description = data_helice[code_helice]
    #conversion au vol et correction avec les valeurs trouvee par la regression
    force_theorique = (1000*Force_Theorique((diametre*0.0254)/2,pitch*0.0254,vitesse_rotation/60)/g) - 0.000008*(vitesse_rotation)**2
    
    if code_helice != code_helice_verif:
        return False
    return force_theorique,force_experimentale
    
def trace_force_corrigee():
    for num_exp in range(1,69):
        code,commande,tension,intensite,RPM,thurst=data_experience[num_exp]
        codebis,pitch,diametre,desc=data_helice[code]
        
        
        thurst_theo,thurst_exp= applique_formule_force_corrigee(num_exp)
        plt.plot(RPM,thurst_theo,'ro',markersize=7)
        plt.plot(RPM,thurst_exp,'bo',markersize=7)
       
        plt.show()

def tracage_verification_thurst_corrigee():
    colors = ['darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','FAIL','darkslateblue','darkslategray','darkturquoise','darkviolet']
    darkblue_line = mlines.Line2D([],[], color='darkblue', label='HQprop 0943 Multirotor')
    darkcyan_line = mlines.Line2D([],[], color='darkcyan', label='HQprop 0945 Multirotor')
    darkgoldenrod_line = mlines.Line2D([],[], color='darkgoldenrod', label='HQprop 0947 Slow-Flyer')
    darkgray_line = mlines.Line2D([],[], color='darkgray', label='HQprop 0950 Thin Electric')
    darkgreen_line = mlines.Line2D([],[], color='darkgreen', label='HQprop 1045 Multirotor')
    darkkhaki_line = mlines.Line2D([],[], color='darkkhaki', label='HQprop 1045 Slow-Flyer')
    darkmagenta_line = mlines.Line2D([],[], color='darkmagenta', label='HQprop 1047 Slow-Flyer')
    darkolivegreen_line = mlines.Line2D([],[], color='darkolivegreen', label='HQprop 1050 Thin Electric')
    darkorange_line = mlines.Line2D([],[], color='darkorange', label='APC 0945 Multirotor')
    darkorchid_line = mlines.Line2D([],[], color='darkorchid', label='APC 0947 Slow-Flyer')
    darkred_line = mlines.Line2D([],[], color='darkred', label='APC 1047 Slow-Flyer')
    darksalmon_line = mlines.Line2D([],[], color='darksalmon', label='APC 1045 Multirotor')
    darkseagreen_line = mlines.Line2D([],[], color='darkseagreen', label='APC 1047 Multirotor')
    darkslateblue_line = mlines.Line2D([],[], color='darkslateblue', label='Gemfan 1038')
    darkslategray_line = mlines.Line2D([],[], color='darkslategray', label='Gemfan 1045')
    darkturquoise_line = mlines.Line2D([],[], color='darkturquoise', label='Graupner 0940')
    darkviolet_line = mlines.Line2D([],[], color='darkviolet', label='Graupner 1040')
    blue_patch = mpatches.Patch(color='blue', label='Valeur théorique')
    red_patch = mpatches.Patch(color='red', label='Valeur expérimentale')
    
    for num_exp in range(1,69):
        code,commande,tension,intensite,RPM,thurst=data_experience[num_exp]
        codebis,pitch,diametre,desc=data_helice[code]

        
        if code!=codebis:
            return 'FAIL'
        
        thurst_theo,thurst_exp= applique_formule_force_corrigee(num_exp)
        plt.plot(RPM,thurst_theo,'ro',markersize=7)
        plt.plot(RPM,thurst_exp,'bo',markersize=7)
        plt.plot([RPM,RPM],[thurst_theo,thurst_exp],label='{}'.format(code),color='{}'.format(colors[code-1]),linewidth=1.5)
    

    
    plt.legend([blue_patch,red_patch,darkblue_line,darkcyan_line,darkgoldenrod_line,darkgray_line,darkgreen_line,darkkhaki_line,darkmagenta_line,darkolivegreen_line,darkorange_line,darkorchid_line,darkred_line,darksalmon_line,darkseagreen_line,darkslateblue_line,darkslategray_line,darkturquoise_line,darkviolet_line],bbox_to_anchor=(1,0.5),loc='center left',fontsize=15)
    
    plt.grid()
    plt.suptitle('Erreur de calcul de la force de poussée',fontsize=25)
    plt.xlabel(r'Vitesse de rotation $ (tour/minute) $',fontsize=20)
    plt.ylabel(r'Force de poussée $ (gramme) $',fontsize=20)
    plt.show()
    #plt.savefig('test.png')
    return 'Done'




## FONCTION DE CALCULES FINALES

def calcul_intensite_force(force,pas,diametre,kv,courant_vide): #force en Newton
    return force * 2
    
def calcul_force_intensite(intensite,pas,diametre,kv,courant_vide): #force en Newton
    return intensite * (1/2)
    
def fonction_utiles(info):
    
    poids_multirotor,nbrmoteur, courantvide_multirotor, capacite_batterie, facteurdecharge_batterie, configuration_batterie, courantcontinue_esc, courantmax_esc, kv_moteur, efficacite_moteur, pas_helice, diametre_helice = info
    
    
    # puissance_moy = tension_nominale*intensite_force(float(pas_helice),float(poids_multirotor)/float(nbre_moteurs))    # U*I en watt

    #   capacite_reelle=0.7*float(capacite_batterie)
    # 
    # f=float(poids)/float(nbre_moteurs)
    # 
    # tps_vol = capacite_reelle*3.6/(intensite_force(float(pas_helice),f)*60)     #capacite de la batterie en mAh ; renvoie le temps de vol en minutes
    
    rapport_poidsforce = 2.5
    tps_vol = 16
    puissance_moy = 130
    
    return tps_vol,puissance_moy,rapport_poidsforce
    

## GRAPHIQUE INTERFACE

from matplotlib import style
import tkinter as tk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg

style.use('ggplot')


def graphique(data):
    
    poids_multirotor,nbrmoteur, courantvide_multirotor, capacite_batterie, facteurdecharge_batterie, configuration_batterie, courantcontinue_esc, courantmax_esc, kv_moteur, efficacite_moteur, pas_helice, diametre_helice = data
    
    fig = Figure(figsize=(15, 5), dpi=100)
    
    # Graphique Intensite(force)
    
    ax_for = fig.add_subplot(121)
    

    intensite_max = min(float(courantmax_esc),(float(capacite_batterie)*(10**(-3))*float(facteurdecharge_batterie))/float(nbrmoteur))
    force_max = calcul_force_intensite(intensite_max, float(pas_helice),  float(diametre_helice), float(kv_moteur), float(courantvide_multirotor))
    
    intensite_max_recom = min(float(courantcontinue_esc),(float(capacite_batterie)*(10**(-3))*float(facteurdecharge_batterie))/float(nbrmoteur) * 0.85)
    force_max_recom = calcul_force_intensite(intensite_max_recom, float(pas_helice),  float(diametre_helice), float(kv_moteur), float(courantvide_multirotor))
    
    force_fonctionnement = (float(poids_multirotor)/float(nbrmoteur))*(10**(-3))*9.81 #Newton
    intensite_fonctionnement = calcul_intensite_force(force_fonctionnement, float(pas_helice),  float(diametre_helice), float(kv_moteur), float(courantvide_multirotor))
    
    
    # Courbe I(f)
    axe_force=[]
    axe_intensite=[]

    for force_mN in range(1,int(((force_max+3)*(10**3))),10):
        force_N=force_mN*(10**(-3))
        
        intensite = calcul_intensite_force(force_N,float(pas_helice), float(diametre_helice),float(kv_moteur),float(courantvide_multirotor))
        
        axe_force.append(force_N)
        axe_intensite.append(intensite)
        
    ax_for.plot(axe_force,axe_intensite)
    
    # Droites caracteristiques

    ax_for.plot([force_fonctionnement,force_fonctionnement],[0,intensite_fonctionnement],'k--')
    ax_for.plot([0,force_fonctionnement],[intensite_fonctionnement,intensite_fonctionnement],'k--')
    ax_for.plot([0,force_max],[intensite_max,intensite_max],'r--')
    ax_for.plot([0,force_max_recom],[intensite_max_recom,intensite_max_recom],'r--')
    
    # Configuration
    ax_for.set_title ("Point de fonctionnement en vol stationnaire d'un moteur", fontsize=16)
    ax_for.set_xlabel(r'Force $ [N] $',fontsize=10)
    ax_for.set_ylabel(r'Intensité $ [A] $',fontsize=10)
    
    ax_for.set_xlim(left=0,right=force_max + 3)
    ax_for.set_ylim(bottom=0)
    
    # Annotation
    intensite_str = str(intensite_fonctionnement)
    intensite_annotation = intensite_str[0:4]
    force_str = str(force_fonctionnement)
    force_annotation = force_str[0:4]
    
    extraticks_x = [force_fonctionnement]
    ax_for.set_xticks(list(ax_for.get_xticks()) + extraticks_x)
    extraticks_y = [intensite_fonctionnement]
    ax_for.set_yticks(list(ax_for.get_yticks()) + extraticks_y)

    ax_for.annotate(r'$( {} A ; {} N )$'.format(force_annotation,intensite_annotation),
        xy=(force_fonctionnement, intensite_fonctionnement), xycoords='data',
        xytext=(-15, 25), textcoords='offset points',
        arrowprops=dict(facecolor='black', shrink=0.02),
        horizontalalignment='right', verticalalignment='bottom')

    ax_for.axvspan(force_max, force_max + 5, facecolor='r', alpha=0.25)
    ax_for.axvspan(force_max_recom, force_max, facecolor='darkorange', alpha=0.25)
    
    
    # Graph Efficacite
    
    ax_eff = fig.add_subplot(122)
    
    # Courbe I(f)
    axe_efficacite= [] # force/intensite
    
    for i in range( len(axe_force) ):
        axe_efficacite.append(axe_force[i] / axe_intensite[i])
    
    ax_eff.plot(axe_force,axe_efficacite)
    
    # Configuration
    ax_eff.set_title ("Efficacité du systeme propulsif", fontsize=16)
    ax_eff.set_ylabel(r'Force/Intensité $ [N/A] $',fontsize=10)
    ax_eff.set_xlabel(r'Force $ [N] $',fontsize=10)
    

    return fig





















